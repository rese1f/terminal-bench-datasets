#include <iostream>
#include <vector>
#include <numeric>
#include <map>
#include <algorithm> // For std::max

int main() {
    // Use fast IO operations
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    
    int t; // Number of test cases
    std::cin >> t;
    while (t--) {
        int n; // Number of elements in the initial array
        std::cin >> n;
        
        // Use a map to store the counts of each number in the initial array `a`.
        // This handles potentially sparse numbers efficiently.
        std::map<int, int> counts;
        int max_a = 0; // Track the maximum value in the initial array
        for (int i = 0; i < n; ++i) {
            int a;
            std::cin >> a;
            counts[a]++;
            // Update the maximum value seen so far
            if (a > max_a) {
                max_a = a;
            }
        }

        // Determine the maximum possible index `k` we might need to consider for counts C_0(k) or increases I_k.
        // The initial maximum value is `max_a`. Values can increase due to operations.
        // A value `k` can be increased to `k+1`. The largest value `k` for which we might need to perform an increase
        // `k -> k+1` seems to be `max_a`. If $I_k > 0$, the value $k+1$ can be generated.
        // We use `M = max_a + 2` as a safe upper bound for indices `k` we need to consider in our vectors.
        // This covers indices up to `max_a + 1`, plus some buffer.
        int M = max_a + 2; 
        
        // `I[k]` will store the total number of times value `k` is increased to `k+1`. Use long long for potentially large counts.
        std::vector<long long> I(M + 1, 0); 
        // `p[k]` stores the required parity of `I_k`. It's based on the prefix sum of parities of initial counts.
        // Specifically, p[k] = (sum_{j=1..k} (C_0(j) mod 2)) mod 2.
        std::vector<int> p(M + 1, 0); 

        // Calculate initial parities `p[k]` and set the minimal required `I[k]` values (0 or 1).
        int current_parity_sum = 0;
        for (int k = 1; k <= M; ++k) {
            int count_k = 0;
            // Safely get the count of `k` from the initial `counts` map.
            auto it = counts.find(k);
            if (it != counts.end()) {
                count_k = it->second;
            }
            // Update the running sum of parities
            current_parity_sum = (current_parity_sum + (count_k % 2)) % 2;
            p[k] = current_parity_sum;
            // The minimal non-negative `I[k]` satisfying the parity requirement `I[k] % 2 == p[k]` is simply `p[k]` itself (since p[k] is 0 or 1).
            I[k] = p[k]; 
        }

        bool possible = true; // Flag to track if a valid sequence of operations exists
        
        // Perform a backward pass from `k = M` down to `1`.
        // This pass adjusts the `I[k]` values to satisfy the necessary condition derived from the operation rules.
        // The condition is: If `I[k] > 0`, then `N_k >= I[k] + 1`, where `N_k = C_0(k) + I_{k-1}` is the total number of items with value `k` available.
        for (int k = M; k >= 1; --k) {
            // Retrieve C_0(k), the initial count of k, safely from the map.
            long long current_count_k = 0;
            auto it = counts.find(k);
             if (it != counts.end()) {
                current_count_k = it->second;
            }
            
            // Calculate N_k = C_0(k) + I_{k-1}. This represents the total number of items of value `k`
            // that are either initially present or generated by increases from `k-1`.
            // Need safe access to I[k-1]. I[0] represents increases for value 0, which is impossible/not needed, so it's 0.
            long long I_k_minus_1 = (k > 1) ? I[k-1] : 0;
            long long Nk = current_count_k + I_k_minus_1; 

            // Check the condition: If we need to perform `I[k] > 0` increases `k -> k+1`, 
            // we must have enough items `k`. Specifically, `N_k` items must be sufficient to provide:
            // - `I[k]` items to be increased (these must be in bag A).
            // - At least 1 item to be moved to bag B to enable the increases.
            // Total required items = `I[k] + 1`.
            if (I[k] > 0) {
                if (Nk < I[k] + 1) {
                    // Condition failed: Not enough items of value `k`. We need `N_k` to be larger.
                    // To increase `N_k`, we must increase `I_{k-1}` (number of increases `k-1 -> k`).
                    long long deficit = (I[k] + 1) - Nk; // How many more items `k` are needed?
                    
                    // If k=1, we need to increase I_0. Increases $0 \to 1$ are not possible starting with positive integers.
                    // Thus, if the condition fails for k=1, it's impossible.
                    if (k == 1) { 
                        possible = false;
                        break; // Exit the loop, as we've found an impossible situation.
                    }

                    // Calculate the minimal *even* non-negative integer `increase_by` such that `Nk + increase_by >= I[k] + 1`.
                    // This increase must be added to `I_{k-1}`. Since `I_{k-1}` must maintain its parity,
                    // any change must be an even number. The minimal required even increase is `2 * ceil(deficit / 2.0)`.
                    // The formula `2 * ((deficit + 1) / 2)` computes this using integer division for `deficit > 0`.
                    long long increase_by = 2 * ((deficit + 1) / 2); 

                    // Apply the calculated increase to `I[k-1]`.
                    I[k-1] += increase_by;
                    
                    // The updated value of `I[k-1]` will be considered when the loop processes `k-1`.
                }
            }
        }
        
        // After the backward pass, if `possible` is still true, it means we found a consistent set of `I[k]` values.
        // There's a small edge case where `I[0]` might become non-zero hypothetically, although the `k=1` check should prevent this.
        // An explicit check for `I[0]` could be added for robustness, but is likely redundant.
        // if (possible && I[0] != 0) { possible = false; } 

        // Output the result based on the final value of the `possible` flag.
        if (possible) {
            std::cout << "Yes\n";
        } else {
            std::cout << "No\n";
        }
    }
    return 0;
}