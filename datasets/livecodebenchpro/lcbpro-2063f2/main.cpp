#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const ll nil=-1;
const ll md=998244353;
 
ll pw(ll a,ll b)
{
    ll c=1;
    while(b>0)
    {
        if(b&1)c=c*a%md;
        a=a*a%md;
        b>>=1;
    }
    return c;
}
 
int main()
{
    cin.tie(0)->sync_with_stdio(0);
    vector<ll>fac(1010101,1),ctl(505050);
    for(int i=1;i<1010101;i++)fac[i]=fac[i-1]*i%md;
    for(int i=0;i<505050;i++)
    {
        ctl[i]=fac[i*2]*pw(fac[i]*fac[i+1]%md,md-2)%md;
    }
    ll t;cin>>t;
    while(t--)
    {
        ll n;cin>>n;
        vector<ll>L(n*2,nil),R(n*2,nil),P(n*2,nil),S(n*2);
        auto update=[&](ll x)
        {
            S[x]=1;
            if(L[x]!=nil)S[x]+=S[L[x]];
            if(R[x]!=nil)S[x]+=S[R[x]];
        };
        auto rotate=[&](ll x)
        {
            ll dummy;
            ll p=P[x];
            ll b=nil;
            if(p==nil)return;
            if(x==L[p])
            {
                L[p]=b=R[x];
                R[x]=p;
            }
            else
            {
                R[p]=b=L[x];
                L[x]=p;
            }
            P[x]=P[p];P[p]=x;
            if(b!=nil)P[b]=p;
            (P[x]!=nil?p==L[P[x]]?L[P[x]]:R[P[x]]:dummy)=x;
            update(p);update(x);
        };
        auto splay=[&](ll x)
        {
            while(P[x]!=nil)
            {
                ll p=P[x];
                ll g=P[p];
                if(g!=nil)
                {
                    if((x==L[p])==(p==L[g]))rotate(p);
                    else rotate(x);
                }
                rotate(x);
            }
        };
        update(0);
        for(int i=1;i<n*2;i++)
        {
            L[i]=i-1;
            P[i-1]=i;
            update(i);
        }
        splay(0);
        ll ans=ctl[n];
        cout<<ans<<" ";
        for(int i=0;i<n;i++)
        {
            ll li,ri;cin>>li>>ri;
            //li=(li+ans%(2*n))%(2*n);
            //ri=(ri+ans%(2*n))%(2*n);
            li--;ri--;
            splay(li);
            ans=ans*pw(ctl[S[li]/2],md-2)%md;
            ll lli=L[li];
            if(L[li]!=nil)P[L[li]]=nil;
            if(R[li]!=nil)P[R[li]]=nil;
            L[li]=nil;
            R[li]=nil;
            update(li);
            // now L[li] separated from tree
            // should not be affected in splay ri
            splay(ri);
            ll lri=L[ri];
            ll rri=R[ri];
            if(L[ri]!=nil)P[L[ri]]=nil;
            if(R[ri]!=nil)P[R[ri]]=nil;
            L[ri]=nil;
            R[ri]=nil;
            update(ri);
            if(lri!=nil)
            {
                splay(lri);
                ans=ans*ctl[S[lri]/2]%md;
            }
            if(lli!=nil&&rri!=nil)
            {
                while(L[rri]!=nil)rri=L[rri];
                splay(lli);
                splay(rri);
                P[lli]=rri;
                L[rri]=lli;
                update(rri);
                ans=ans*ctl[S[rri]/2]%md;
            }
            else if(lli!=nil||rri!=nil)
            {
                if(lli!=nil)
                {
                    splay(lli);
                    ans=ans*ctl[S[lli]/2]%md;
                }
                else
                {
                    splay(rri);
                    ans=ans*ctl[S[rri]/2]%md;
                }
            }
            L[ri]=li;
            P[li]=ri;
            update(ri);
            // make dummy tree (for invariant maintaining)
            cout<<ans<<" \n"[i+1==n];
        }
    }
}